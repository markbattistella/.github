#!/bin/bash
# Scans all repos for a given GitHub user and finds tags with zero-padded
# month or day segments. Outputs a ready-to-run fix_tags.sh if any are found.
# Requires: gh (GitHub CLI), authenticated via `gh auth login`

# ── Configuration ────────────────────────────────────────────────────────────
TARGET_USER="${1:-}"
# ─────────────────────────────────────────────────────────────────────────────

if [ -z "$TARGET_USER" ]; then
  echo "Usage: ./scan_tags.sh <github-username>"
  exit 1
fi

# Check if the current authenticated user matches the target
AUTHED_USER=$(gh api user --jq '.login' 2>/dev/null)

if [ "$AUTHED_USER" = "$TARGET_USER" ]; then
  IS_SELF=true
  echo "✓ Authenticated as '$TARGET_USER' — scanning public and private repos."
else
  IS_SELF=false
  echo "ℹ Scanning public repos only for '$TARGET_USER' (not authenticated as them)."
fi

echo ""

# Fetch all repos via paginated API
echo "Fetching repos for '$TARGET_USER'..."

REPOS=()
PAGE=1

while true; do
  if [ "$IS_SELF" = true ]; then
    # Authenticated user — use /user/repos to get all repos including private
    BATCH=$(gh api "user/repos?per_page=100&page=$PAGE&affiliation=owner" --jq '.[].full_name' 2>&1)
  else
    # Other user — public repos only
    BATCH=$(gh api "users/$TARGET_USER/repos?per_page=100&page=$PAGE" --jq '.[].full_name' 2>&1)
  fi

  if [ -z "$BATCH" ]; then
    break
  fi

  while IFS= read -r REPO; do
    REPOS+=("$REPO")
  done <<< "$BATCH"

  # If fewer than 100 results, we've hit the last page
  # tr -d ' ' trims the whitespace that wc -l includes on macOS
  BATCH_COUNT=$(echo "$BATCH" | wc -l | tr -d ' ')
  if [ "$BATCH_COUNT" -lt 100 ]; then
    break
  fi

  PAGE=$((PAGE + 1))
done

REPO_COUNT=${#REPOS[@]}

if [ "$REPO_COUNT" -eq 0 ]; then
  echo "No repos found for '$TARGET_USER'."
  exit 0
fi

echo "Found $REPO_COUNT repos. Scanning tags..."
echo ""

# Repos that contain at least one zero-padded tag
AFFECTED_REPOS=()

for FULL in "${REPOS[@]}"; do
  # Extract just the repo name from the owner/repo string
  REPO=$(echo "$FULL" | cut -d'/' -f2)

  # Fetch all tags
  TAGS_JSON=$(gh api "repos/$FULL/git/refs/tags" 2>/dev/null)

  if [ -z "$TAGS_JSON" ] || [ "$TAGS_JSON" = "[]" ]; then
    continue
  fi

  # Extract tag names
  ALL_TAGS=$(echo "$TAGS_JSON" | grep -oE '"ref":\s*"refs/tags/[^"]+"' | sed -E 's|"ref":\s*"refs/tags/||;s|"||g')

  # Filter to zero-padded month or day
  MATCHED=$(echo "$ALL_TAGS" | grep -E '^[0-9]+\.0[0-9]+\.[0-9]+$|^[0-9]+\.[0-9]+\.0[0-9]+$')

  if [ -n "$MATCHED" ]; then
    echo "  ⚠ $REPO"
    while IFS= read -r TAG; do
      NEW_TAG=$(echo "$TAG" | sed -E 's/^([0-9]+)\.0*([1-9][0-9]*)\.0*([1-9][0-9]*)$/\1.\2.\3/')
      echo "    $TAG → $NEW_TAG"
    done <<< "$MATCHED"
    AFFECTED_REPOS+=("$REPO")
  fi
done

echo ""

if [ ${#AFFECTED_REPOS[@]} -eq 0 ]; then
  echo "✓ No zero-padded tags found across any repos. Nothing to fix!"
  exit 0
fi

# ── Generate fix script ───────────────────────────────────────────────────────
OUTPUT_FILE="fix_tags.sh"

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "Found zero-padded tags in ${#AFFECTED_REPOS[@]} repo(s)."
echo "Generating '$OUTPUT_FILE'..."
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""

# Build the REPOS array body for the generated script
REPOS_LIST=""
for R in "${AFFECTED_REPOS[@]}"; do
  REPOS_LIST="${REPOS_LIST}  \"$R\"\n"
done

# Write the fix script via heredoc, escaping variables meant to run at fix-time
cat > "$OUTPUT_FILE" << FIXEOF
#!/bin/bash
# Auto-generated by scan_tags.sh
# Fixes zero-padded tags (e.g. 26.02.07 → 26.2.7) across affected repos.
# Requires: gh (GitHub CLI), authenticated via \`gh auth login\`

# ── Configuration ────────────────────────────────────────────────────────────
OWNER="$TARGET_USER"
REPOS=(
$(printf "$REPOS_LIST")
)
# ─────────────────────────────────────────────────────────────────────────────

SUCCEEDED=()
FAILED=()
SKIPPED=()

for REPO in "\${REPOS[@]}"; do
  FULL="\$OWNER/\$REPO"
  echo "▶ Processing \$FULL"

  TAGS_JSON=\$(gh api "repos/\$FULL/git/refs/tags" 2>&1) || {
    FAILED+=("\$REPO — Could not fetch tags: \$TAGS_JSON")
    echo "  ✗ Could not fetch tags"
    echo ""
    continue
  }

  ALL_TAGS=\$(echo "\$TAGS_JSON" | grep -oE '"ref":\s*"refs/tags/[^"]+"' | sed -E 's|"ref":\s*"refs/tags/||;s|"||g')
  MATCHED=\$(echo "\$ALL_TAGS" | grep -E '^[0-9]+\.0[0-9]+\.[0-9]+\$|^[0-9]+\.[0-9]+\.0[0-9]+\$')

  if [ -z "\$MATCHED" ]; then
    echo "  No zero-padded tags found, skipping."
    SKIPPED+=("\$REPO")
    echo ""
    continue
  fi

  REPO_HAD_FAILURE=false

  while IFS= read -r OLD_TAG; do
    NEW_TAG=\$(echo "\$OLD_TAG" | sed -E 's/^([0-9]+)\.0*([1-9][0-9]*)\.0*([1-9][0-9]*)\$/\1.\2.\3/')

    if [ "\$OLD_TAG" = "\$NEW_TAG" ]; then
      echo "  Skipping '\$OLD_TAG' — no change needed."
      continue
    fi

    echo "  Found '\$OLD_TAG' → will rename to '\$NEW_TAG'"

    SHA=\$(gh api "repos/\$FULL/git/refs/tags/\$OLD_TAG" --jq '.object.sha' 2>&1) || {
      FAILED+=("\$REPO (\$OLD_TAG) — Could not resolve SHA: \$SHA")
      echo "  ✗ Could not resolve SHA for '\$OLD_TAG'"
      REPO_HAD_FAILURE=true
      continue
    }

    OBJ_TYPE=\$(gh api "repos/\$FULL/git/refs/tags/\$OLD_TAG" --jq '.object.type' 2>&1)
    if [ "\$OBJ_TYPE" = "tag" ]; then
      SHA=\$(gh api "repos/\$FULL/git/tags/\$SHA" --jq '.object.sha' 2>&1) || {
        FAILED+=("\$REPO (\$OLD_TAG) — Could not dereference annotated tag: \$SHA")
        echo "  ✗ Could not dereference annotated tag '\$OLD_TAG'"
        REPO_HAD_FAILURE=true
        continue
      }
    fi

    echo "    SHA: \$SHA"

    DELETE_OUTPUT=\$(gh api "repos/\$FULL/git/refs/tags/\$OLD_TAG" --method DELETE 2>&1) || {
      FAILED+=("\$REPO (\$OLD_TAG) — Could not delete old tag: \$DELETE_OUTPUT")
      echo "  ✗ Could not delete '\$OLD_TAG'"
      REPO_HAD_FAILURE=true
      continue
    }
    echo "    Deleted '\$OLD_TAG'"

    CREATE_OUTPUT=\$(gh api "repos/\$FULL/git/refs" \\
      --method POST \\
      --field ref="refs/tags/\$NEW_TAG" \\
      --field sha="\$SHA" 2>&1) || {
      FAILED+=("\$REPO (\$OLD_TAG → \$NEW_TAG) — Could not create new tag: \$CREATE_OUTPUT")
      echo "  ✗ Could not create '\$NEW_TAG' (old tag deleted — manual fix needed at SHA: \$SHA)"
      REPO_HAD_FAILURE=true
      continue
    }
    echo "    Created '\$NEW_TAG'"

    SUCCEEDED+=("\$REPO: \$OLD_TAG → \$NEW_TAG")
  done <<< "\$MATCHED"

  echo ""
done

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "REPORT"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

if [ \${#SUCCEEDED[@]} -gt 0 ]; then
  echo ""
  echo "✓ Renamed (\${#SUCCEEDED[@]}):"
  for R in "\${SUCCEEDED[@]}"; do
    echo "  • \$R"
  done
fi

if [ \${#SKIPPED[@]} -gt 0 ]; then
  echo ""
  echo "— Skipped, nothing to fix (\${#SKIPPED[@]}):"
  for R in "\${SKIPPED[@]}"; do
    echo "  • \$R"
  done
fi

if [ \${#FAILED[@]} -gt 0 ]; then
  echo ""
  echo "✗ Failed (\${#FAILED[@]}):"
  for R in "\${FAILED[@]}"; do
    echo "  • \$R"
  done
fi

echo ""
FIXEOF

chmod +x "$OUTPUT_FILE"

echo "Ready! To fix all affected repos, run:"
echo ""
echo "  ./$OUTPUT_FILE"
echo ""
